<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Liskov helyettesítés sértése</title>
        <para>
Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a
megoldásra: jobb OO tervezés.
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (93-99 fólia)
(számos példa szerepel az elv megsértésére az UDPROG repóban, lásd pl. source/binom/BatfaiBarki/madarak/)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: https://github.com/Drcsonka/Prog2/blob/master/liskovsert.cpp               
        </para>
        <para>

Az elv lényege hogy minden alap osztály legyen helyettesíthető az leszármazott osztályával.Vagyis 
ha az alap osztály nem valt ki semmit akkor a leszármazott osztály se valtson ki, vagyis a program működése nem változik.
Aza  feladatunk, hogy csináljunk egy olyan programot ami ezt az elvet sérti.
A kódunkat nézve, van egy Madar osztályunk, ami tartalmazza a "repules()" funkciót. Ezen kívül létrehozunk két alosztályt ezek lesznek a Madar leszármazott osztályai. Mindketttő osztály ( sas és pingvin ) örökölni fogja a "repules()"-t funkciot. A program szintaktikailag helyes ezzel nincs is baj, de viszont logikailag nem helyes, mert a sas tud repülni, de a pingvin már nem. És így megsértjük a Liskov elvet ami a feladatunk volt.
Ezt a hibat úgy tudnánk kiküszöbölni, hogy a "Madar" osztályon belül létrehoznank egy "repulomadarak" osztalyt és ez kapna majd meg a "repules()" funkciot. Igy különbséget tudnánk tenni repülő és nem repülő madarak között.
        </para>
    </section>        

    <section>
        <title>Szülő-gyerek</title>
        <para>
            Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön
keresztül csak az ős üzenetei küldhetőek!
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (98. fólia)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:      https://github.com/Drcsonka/Prog2/blob/master/szulogyermek.java
https://github.com/Drcsonka/Prog2/blob/master/szulogyermek.cpp          
        </para>
        <para>
            A feladatunk ebben a programban az lenne, hogy egy szülő-gyermek példát mutassunk be, hasonlóan az előző feladatunkhoz. A programunk rendelkezik egy "teglalap" nevű osztállyal amely rendelkezik egy "meret" nevu funkcioval ami két értéket fog tartalmazni, ami a Szélesség és a Magasság lesz. A "teglalap" osztályunk rendelkezni fog egy "negyzet" nevű alosztállyal.
Ez az alosztály rendelkezni fog a "terület" nevű függvénnyel. A programunk ott fog elbukni, hogy a futásnál a "terulet" függvényt a téglalapra akarjuk meghívni, de mivel a téglalap osztály nem rendelkezik a "terulet" függvénnyel, így hibába fut és nem fog tudni lefutni.
        </para>
    </section>        
<section>
        <title>Anti OO</title>
        <para>
            A BBP algoritmussal4
a Pi hexadecimális kifejtésének a 0. pozíciótól számított 106, 107, 108 darab
jegyét határozzuk meg C, C++, Java és C# nyelveken és vessük össze a futási időket!
https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apas03.html#id561066
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: https://github.com/Drcsonka/Prog2/blob/master/antioo.java
			https://github.com/Drcsonka/Prog2/blob/master/antioo.c               
        </para>
        <para>
            Ehhez a feladathoz a mar megcsinalt, BPP algoritmust fogjuk hasznalni, csak most a feladatunk az lesz, hogy a PI-nek kell a 10<superscript>6</superscript> 10<superscript>7</superscript> 10<superscript>8</superscript> darab jegyet kiszamolnunk és megkell néznünk, hogy melyik nyelvben milyen gyorsan tudja ezt a feladatot megoldani és kiszamolni ( Ezek a nyelvek a "C, C++, Java, C#").
Ahhoz, hogy ezeket a futási időket megkapjuk a terminálban, az kódunkba a d értékét kell implementalnunk. Ha a 10^6 jegyét szeretnénk meghatározni, akkor a "for" ciklusban a d-t 1000000-re kell beállítanunk.
        </para>
    </section>        
<section>
        <title>Hello, Android!</title>
        <para>
            Élesszük fel az SMNIST for Humans projektet!
https://gitlab.com/nbatfai/smnist/tree/master/forHumans/SMNISTforHumansExp3/app/src/main
Apró módosításokat eszközölj benne, pl. színvilág.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
<section>
        <title>Ciklomatikus komplexitás</title>
        <para>
            Számoljuk ki valamelyik programunk függvényeinek ciklomatikus komplexitását! Lásd a fogalom
tekintetében a https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_2.pdf (77-79
fóliát)!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
